package ministub

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"strings"
	"text/template"

	"golang.org/x/tools/imports"
)

const stubTemplate = `// Code generated by ministub; DO NOT EDIT.
package {{.PackageName}}

{{- range .Interfaces}}
{{- $interfaceName := .Name}}
// Fake{{$interfaceName}} implements {{$interfaceName}}.
type Fake{{$interfaceName}} struct {
{{- range .Methods}}
    {{.MethodName}}Stub func({{.Params}}) {{.Results}}
{{- end}}
}

{{- range .Methods}}
func (fakeImpl *Fake{{$interfaceName}}) {{.MethodName}}({{.Params}}) {{.Results}} {
    return fakeImpl.{{.MethodName}}Stub({{.ParamNames}})
}
{{- end}}
{{- end}}
`

type MethodData struct {
	MethodName string
	Params     string
	Results    string
	ParamNames string
}

type InterfaceData struct {
	Name    string
	Methods []*MethodData
}

// ParseAndStub will read from filepath, or directly use src if filepath is empty, to parse
// and generate a stubbed fake implementation of interfaceName. src will not be used if filepath
// is provided.
func ParseAndStub(interfaceNames []string, filepath, src string, formatted bool) ([]byte, error) {
	fset := token.NewFileSet()
	var err error
	var node *ast.File
	if filepath != "" {
		node, err = parser.ParseFile(fset, filepath, nil, parser.ParseComments)
		if err != nil {
			return nil, fmt.Errorf("could not parse file: %w", err)
		}

	} else {
		node, err = parser.ParseFile(fset, "", src, parser.ParseComments)
		if err != nil {
			return nil, fmt.Errorf("could not parse src: %w", err)
		}
	}

	packageName := node.Name.Name
	var interfaces []*InterfaceData
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}
			interfaceName := typeSpec.Name.Name
			if !contains(interfaceNames, interfaceName) {
				continue
			}
			var methods []*MethodData
			for _, m := range interfaceType.Methods.List {
				methods = append(methods, &MethodData{
					MethodName: m.Names[0].Name,
					Params:     paramsToString(m.Type.(*ast.FuncType).Params),
					Results:    resultsToString(m.Type.(*ast.FuncType).Results),
					ParamNames: paramNamesToString(m.Type.(*ast.FuncType).Params),
				})
			}
			interfaces = append(interfaces, &InterfaceData{
				Name:    interfaceName,
				Methods: methods,
			})
		}
	}

	tmpl, err := template.New("stub").Parse(stubTemplate)
	if err != nil {
		return nil, fmt.Errorf("could not parse stub template: %w", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		PackageName string
		Interfaces  []*InterfaceData
	}{
		PackageName: packageName,
		Interfaces:  interfaces,
	})
	if err != nil {
		return nil, fmt.Errorf("could not execute stub template: %w", err)
	}

	bs, err := imports.Process("ministub_tmp_goimports", buf.Bytes(), nil)
	if err != nil {
		return nil, fmt.Errorf("could not call goimports on source: %w", err)
	}

	if formatted {
		formattedCode, err := format.Source(bs)
		if err != nil {
			return nil, fmt.Errorf("failed to format source: %w", err)
		}
		return formattedCode, nil
	}

	return bs, nil

}

func contains(slice []string, str string) bool {
	for _, item := range slice {
		if item == str {
			return true
		}
	}
	return false
}

func paramsToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var params []string
	for i, field := range fields.List {
		typeString := fieldTypeToString(field.Type)
		if len(field.Names) == 0 {
			params = append(params, fmt.Sprintf("arg%d %s", i, typeString))
		} else {
			for _, name := range field.Names {
				params = append(params, name.Name+" "+typeString)
			}
		}
	}

	return strings.Join(params, ", ")
}

func resultsToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var params []string
	for _, field := range fields.List {
		typeString := fieldTypeToString(field.Type)
		if len(field.Names) == 0 {
			params = append(params, typeString)
		} else {
			for _, name := range field.Names {
				params = append(params, name.Name+" "+typeString)
			}
		}
	}
	if len(params) == 1 {
		return params[0]
	}

	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func fieldTypeToString(expr ast.Expr) string {
	var sb strings.Builder
	err := format.Node(&sb, token.NewFileSet(), expr)
	if err != nil {
		panic("failed to convert field type to string: " + err.Error())
	}
	return sb.String()
}

func paramNamesToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var names []string
	for i, field := range fields.List {
		callSuffix := ""
		if _, isVariadic := field.Type.(*ast.Ellipsis); isVariadic {
			callSuffix = "..."
		}

		if len(field.Names) == 0 {
			names = append(names, fmt.Sprintf("arg%d%s", i, callSuffix))
			continue
		}
		for _, name := range field.Names {
			names = append(names, name.Name+callSuffix)
		}
	}

	return strings.Join(names, ",")
}
