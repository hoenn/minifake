package ministub

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"strings"
	"text/template"
)

const stubTemplate = `// Code generated by ministub; DO NOT EDIT.
package {{.PackageName}}

// Fake{{.InterfaceName}} implements {{.InterfaceName}}.
type Fake{{.InterfaceName}} struct {
{{- range .Methods}}
    {{.Name}}Stub func({{.Params}}) {{.Results}}
{{- end}}
}

{{- range .Methods}}
func (f *Fake{{$.InterfaceName}}) {{.Name}}({{.Params}}) {{.Results}} {
    return f.{{.Name}}Stub({{.ParamNames}})
}
{{- end}}
`

type MethodData struct {
	Name       string
	Params     string
	Results    string
	ParamNames string
}

// ParseAndStub will read from filepath, or directly use src if filepath is empty, to parse
// and generate a stubbed fake implementation of interfaceName. src will not be used if filepath
// is provided.
func ParseAndStub(interfaceName, filepath, src string, formatted bool) ([]byte, error) {
	fset := token.NewFileSet()
	var err error
	var node *ast.File
	if filepath != "" {
		node, err = parser.ParseFile(fset, filepath, nil, parser.ParseComments)
		if err != nil {
			return nil, fmt.Errorf("could not parse file: %w", err)
		}

	} else {
		node, err = parser.ParseFile(fset, "", src, parser.ParseComments)
		if err != nil {
			return nil, fmt.Errorf("could not parse src: %w", err)
		}
	}

	packageName := node.Name.Name
	var methods []MethodData
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			continue
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok || typeSpec.Name.Name != interfaceName {
				continue
			}

			interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
			if !ok {
				continue
			}

			for _, m := range interfaceType.Methods.List {
				methodName := m.Names[0].Name
				methodParams := paramsToString(m.Type.(*ast.FuncType).Params)
				methodResults := resultsToString(m.Type.(*ast.FuncType).Results)
				methodParamNames := paramNamesToString(m.Type.(*ast.FuncType).Params)

				methods = append(methods, MethodData{
					Name:       methodName,
					Params:     methodParams,
					Results:    methodResults,
					ParamNames: methodParamNames,
				})
			}
		}
	}

	tmpl, err := template.New("stub").Parse(stubTemplate)
	if err != nil {
		return nil, fmt.Errorf("could not parse stub template: %w", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		FileName      string
		PackageName   string
		InterfaceName string
		Methods       []MethodData
	}{
		PackageName:   packageName,
		InterfaceName: interfaceName,
		Methods:       methods,
	})
	if err != nil {
		return nil, fmt.Errorf("could not execute stub template: %w", err)
	}

	if formatted {
		formattedCode, err := format.Source(buf.Bytes())
		if err != nil {
			return nil, fmt.Errorf("failed to format source: %w", err)
		}
		return formattedCode, nil
	}
	return buf.Bytes(), nil

}

func paramsToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var params []string
	for _, field := range fields.List {
		typeString := fieldTypeToString(field.Type)
		if len(field.Names) == 0 {
			params = append(params, typeString)
		} else {
			for _, name := range field.Names {
				params = append(params, name.Name+" "+typeString)
			}
		}
	}

	return strings.Join(params, ", ")
}

func resultsToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var params []string
	for _, field := range fields.List {
		typeString := fieldTypeToString(field.Type)
		if len(field.Names) == 0 {
			params = append(params, typeString)
		} else {
			for _, name := range field.Names {
				params = append(params, name.Name+" "+typeString)
			}
		}
	}
	if len(params) == 1 {
		return params[0]
	}

	return fmt.Sprintf("(%s)", strings.Join(params, ", "))
}

func fieldTypeToString(expr ast.Expr) string {
	var sb strings.Builder
	err := format.Node(&sb, token.NewFileSet(), expr)
	if err != nil {
		panic("failed to convert field type to string: " + err.Error())
	}
	return sb.String()
}

func paramNamesToString(fields *ast.FieldList) string {
	if fields == nil {
		return ""
	}

	var names []string
	for _, field := range fields.List {
		for _, name := range field.Names {
			names = append(names, name.Name)
		}
	}

	return strings.Join(names, ",")
}
